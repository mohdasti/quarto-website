---
title: "Surgeon Cognitive Dashboard — Case Study"
subtitle: "Zero-headgear neuro-ergonomics for robotic surgery"
author: "Mohammad Dastgheib"
format:
  html:
    theme: flatly
    toc: true
    toc-depth: 3
    number-sections: false
    smooth-scroll: true
    lightbox: auto
execute:
  echo: false
  message: false
  warning: false
---

```{=html}
<style>
/* --- Minimal clinical theme (inline; no external files) --- */
:root {
  --ink:#0b1526; --muted:#4b5563; --bg:#f7f9fc; --card:#ffffff;
  --accent:#1f9bb6; --ok:#27ae60; --warn:#f39c12; --crit:#e74c3c; --border:#e5e7eb;
}
body { color:var(--ink); background:var(--bg); }
h1,h2,h3 { letter-spacing:.2px; }
a { color:var(--accent); }
.quarto-title-banner { background:var(--card); border-bottom:1px solid var(--border); }
.figure img, video { border:1px solid var(--border); border-radius:12px; }
.gt_table { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
.gt_table .gt_row { font-variant-numeric: tabular-nums; }
.callout { border-left-color: var(--accent) !important; }
</style>
```

::: callout-tip
**TL;DR —** Reduce **High-Load minutes/hour**, prevent **lapses**, and keep trainees in the **optimal zone** using **pupil + grip/tremor + HRV** (no headgear). This page first **teaches why thresholds must adapt** (interactive Training Lab), then shows the **production dashboard**, and finally the **metrics ops leaders care about**.
:::

## Why I built this

```{=html}

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">

<!-- Enable Bootstrap 5 tooltips (hover-activated, with guards) -->
<script>
window.addEventListener('DOMContentLoaded', () => {
  if (!window.bootstrap || !bootstrap.Tooltip) return; // guard
  // Add a custom class to all tooltips by default (wider, readable)
  document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(el => {
    if (!el.dataset.bsCustomClass) el.dataset.bsCustomClass = 'tt-wide';
    el.setAttribute('tabindex', '0'); // keyboard focus
    new bootstrap.Tooltip(el, {container: 'body', trigger: 'hover focus', html: true});
  });
});
</script>

<style>
/* Wider, cleaner tooltips */
.tt-wide .tooltip-inner{
  max-width: 340px;           /* default ~200px can feel cramped */
  text-align: left;
  line-height: 1.25;
  padding: .45rem .55rem;
}
/* Slightly bigger hit area for the ⓘ pill */
.help-icon{display:inline-flex;align-items:center;justify-content:center;
  width:1.05em;height:1.05em;border-radius:999px;border:1px solid #e5e7eb;
  color:#1f9bb6;font-size:.8em;margin-left:.25rem;cursor:help;vertical-align:baseline}
.help-icon:hover{background:#e6f6fb;border-color:#b7e1f0}
.help-icon i{font-size:1em}
</style>

<!-- ===== Enriched SST + PhD section with hover help ===== -->

<p>
<strong><a href="https://www.surgicalsafety.com/" target="_blank" rel="noopener">Surgical Safety Technologies (SST)</a></strong>
(Research Assistant / AI Annotator).
</p>

<ul>
  <li>
    Assisted on <em>instance segmentation</em>
    <span class="help-icon"
          data-bs-toggle="tooltip"
          title="Pixel-wise masks for each instrument (vs. boxes only), which enables occlusion-aware tracking and per-tool metrics. Useful downstream for contact detection &amp; dwell time.">
      <i class="bi bi-info-circle"></i>
    </span>
    for tool detection/tracking
  </li>

  <li>
    Computed <em>inter-rater reliability</em> (κ/ICC)
    <span class="help-icon"
          data-bs-toggle="tooltip"
          title="<b>κ (kappa):</b> categorical agreement adjusted for chance<br><b>ICC:</b> continuous/interval agreement across raters<br>Heuristics: κ ≥ 0.60 / ICC ≥ 0.75 = acceptable for ops; re-train below">
      <i class="bi bi-info-circle"></i>
    </span>
    for analyst labels
  </li>

  <li>
    Reviewed ML-for-safety literature
    <span class="help-icon"
          data-bs-toggle="tooltip"
          title="Streams: adverse-event detection, tool usage analytics, OR black-box &amp; safety auditing; emphasis on deployability and annotation quality.">
      <i class="bi bi-info-circle"></i>
    </span>
    to support analyst operations
  </li>
</ul>

<p style="margin:.25rem 0 0">
  → <strong>Lesson:</strong> <em>labels drift</em>
  <span class="help-icon" role="button" aria-label="What is label drift?"
        data-bs-toggle="tooltip"
        title="Definitions &amp; mental models shift over time and across raters (ontology changes, UI nudges). Mitigations: κ/ICC gates, versioned rubrics, targeted re-labeling.">
    <i class="bi bi-info-circle" aria-hidden="true"></i>
  </span>,
  <em>interfaces &amp; alarm hygiene decide adoption</em>
  <span class="help-icon" role="button" aria-label="Why does alarm hygiene matter?"
        data-bs-toggle="tooltip"
        title="Target ≤ <b>0.6 alerts/min</b> (median)<br>Context-aware suppression during critical actions<br>Explainable triggers: e.g., <b>HRV↓ + TEPR↑</b><br>Snooze/decay to prevent repeats; short, actionable text">
    <i class="bi bi-info-circle" aria-hidden="true"></i>
  </span>.
</p>

<hr style="border:none;border-top:1px solid #e5e7eb;margin:1rem 0" />

<p>
<strong><a href="https://mdastgheib.com/research/" target="_blank" rel="noopener">UC Riverside</a></strong>
(PhD project and dissertation).
</p>

<ul>
  <li>
    Test concurrent physical (<b>5% vs 40% MVC</b>
    <span class="help-icon"
          data-bs-toggle="tooltip"
          title="MVC = Maximum Voluntary Contraction. 5% ≈ light isometric grip; 40% ≈ high effort.">
      <i class="bi bi-info-circle"></i>
    </span>)
    × cognitive effort with <em>pupillometry</em>
    <span class="help-icon"
          data-bs-toggle="tooltip"
          title="<b>Tonic</b> (baseline diameter) ≈ arousal state<br><b>TEPR</b> (task-evoked) ≈ phasic LC-NE response<br>Used alongside HRV to disambiguate stress vs. lapse">
      <i class="bi bi-info-circle"></i>
    </span>
  </li>

  <li>
    Domains: working/long-term memory + auditory/visual discrimination
    <span class="help-icon"
          data-bs-toggle="tooltip"
          title="Cross-domain design tests generality of arousal effects beyond a single task family.">
      <i class="bi bi-info-circle"></i>
    </span>
  </li>

  <li>
    Theories: <em>Resource Competition</em>
    <span class="help-icon"
          data-bs-toggle="tooltip"
          title="Shared resources → physical effort can tax/exacerbate cognitive load, producing performance trade-offs.">
      <i class="bi bi-info-circle"></i>
    </span>
    + <em>Neural Gain (adaptive gain)</em>
    <span class="help-icon"
          data-bs-toggle="tooltip"
          title="LC–NE modulates neural gain; mid-level arousal optimizes performance (inverted-U), extremes hurt it.">
      <i class="bi bi-info-circle"></i>
    </span>
  </li>
</ul>

<p style="margin:.25rem 0 0">
  → <strong>Mechanism:</strong> <em>pupil-indexed LC–NE</em>
  <span class="help-icon"
        data-bs-toggle="tooltip"
        title="Pupil diameter tracks LC–NE activity (tonic &amp; phasic). In the dashboard, TEPR↑ + HRV↓ = High-Load confirmation; low TEPR + blink anomalies → Lapse confirmation. This supports thresholds that adapt with time-on-task and recover after microbreaks.">
    <i class="bi bi-info-circle"></i>
  </span>
  links arousal to performance.
</p>

<hr style="border:none;border-top:1px solid #e5e7eb;margin:1rem 0" />

<p><strong>Why this dashboard:</strong> combine deployable UX from SST with mechanistic LC–NE insight to deliver a
  <b>training-first, zero-headgear</b> cognitive monitor for robotic trainees.</p>
```

------------------------------------------------------------------------

## Executive Summary

Surgery is a cognitive sport. When arousal is balanced, performance peaks; when it's too low or too high, errors creep in. The OR is tightly constrained—so we avoid new body-worn hardware and lengthy calibration, and instead fuse existing robot telemetry with unobtrusive biosignals to deliver real-time coaching.

I built two tightly coupled tools:

- **Training Lab**: makes load/fatigue *felt* and lets instructors choose a threshold policy to match their pedagogy.
- **Production Dashboard**: runs those policies in real time using **pupil + grip/tremor + HRV**, tuned to prevent alarm fatigue and respect sterile-field constraints.

Accuracy is necessary, not sufficient. We optimize for operational outcomes—fewer high-load minutes, faster recovery, quicker proficiency—alongside standard model metrics.

::: {.callout-note}
**Deployment KPIs:** Alert burden ≤ **0.6/min**, High-Load **min/hr ↓**, Time-to-Recovery **sec ↓**, Acknowledgement rate **↑**.
:::


```{=html}
<style>
.repo-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;margin:.6rem 0}
.repo-card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:14px 14px 12px;
  box-shadow:0 1px 1px rgba(16,24,40,.02);transition:transform .16s ease,box-shadow .16s ease}
.repo-card:hover{transform:translateY(-1px);box-shadow:0 4px 14px rgba(16,24,40,.06);border-color:#cfe8f3}
.repo-card:focus-within{outline:2px solid #b7e1f0;outline-offset:2px}
.repo-head{display:flex;align-items:center;gap:8px}
.repo-head .stack{display:flex;align-items:center;gap:8px}
.repo-head i{font-size:1.05rem;color:#1f9bb6}
.repo-title{font-weight:600}
.repo-desc{color:#4b5563;margin:.35rem 0 .5rem;font-size:.95rem}
.repo-bar{display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap}
.repo-badges{display:flex;gap:6px;flex-wrap:wrap}
.repo-badges img{height:18px;border-radius:6px;border:1px solid #edf0f3}
.repo-actions{display:flex;gap:8px}
.repo-actions a.btn{display:inline-flex;align-items:center;gap:.45rem;font-size:.85rem;padding:.30rem .62rem;border-radius:8px;
  border:1px solid #d7dee6;background:#f8fafc;color:#0b1526;text-decoration:none}
.repo-actions a.btn.primary{background:#e6f6fb;border-color:#b7e1f0}
.repo-actions a.btn i{font-size:1rem}
</style>

<div class="repo-grid">

  <div class="repo-card" role="group" aria-label="Surgical Cognitive Dashboard repository">
    <div class="repo-head">
      <div class="stack">
        <i class="bi bi-activity" aria-hidden="true"></i>
        <div class="repo-title">Surgical Cognitive Dashboard</div>
      </div>
      <i class="bi bi-github" aria-hidden="true" title="GitHub repository"></i>
    </div>
    <div class="repo-desc">Zero-headgear, real-time neuro-ergonomics for robotic surgery.</div>
    <div class="repo-bar">
      <div class="repo-badges">
        <img alt="GitHub stars" loading="lazy"
             src="https://img.shields.io/github/stars/mohdasti/surgical-cognitive-dashboard?style=flat-square&label=Stars">
        <img alt="Last commit" loading="lazy"
             src="https://img.shields.io/github/last-commit/mohdasti/surgical-cognitive-dashboard?style=flat-square">
      </div>
      <div class="repo-actions">
        <a class="btn primary" href="https://github.com/mohdasti/surgical-cognitive-dashboard"
           target="_blank" rel="noopener" aria-label="Open Surgical Cognitive Dashboard repository on GitHub">
          <i class="bi bi-github" aria-hidden="true"></i>Open repo
        </a>
      </div>
    </div>
  </div>

  <div class="repo-card" role="group" aria-label="Surgical Training Lab repository">
    <div class="repo-head">
      <div class="stack">
        <i class="bi bi-mortarboard" aria-hidden="true"></i>
        <div class="repo-title">Surgical Training Lab</div>
      </div>
      <i class="bi bi-github" aria-hidden="true" title="GitHub repository"></i>
    </div>
    <div class="repo-desc">Interactive policy sandbox: Inverted-U · SDT · Fatigue-adaptive.</div>
    <div class="repo-bar">
      <div class="repo-badges">
        <img alt="GitHub stars" loading="lazy"
             src="https://img.shields.io/github/stars/mohdasti/surgical-training-lab?style=flat-square&label=Stars">
        <img alt="Last commit" loading="lazy"
             src="https://img.shields.io/github/last-commit/mohdasti/surgical-training-lab?style=flat-square">
      </div>
      <div class="repo-actions">
        <a class="btn" href="https://0z6q8c-mohammad0dastgheib.shinyapps.io/surgical-training-lab/"
           target="_blank" rel="noopener" aria-label="Open live demo of Surgical Training Lab">
          <i class="bi bi-display" aria-hidden="true"></i>Live demo
        </a>
        <a class="btn primary" href="https://github.com/mohdasti/surgical-training-lab"
           target="_blank" rel="noopener" aria-label="Open Surgical Training Lab repository on GitHub">
          <i class="bi bi-github" aria-hidden="true"></i>Open repo
        </a>
      </div>
    </div>
  </div>

</div>
```

------------------------------------------------------------------------

## Threshold Policies — how they work

*One problem, three lenses.* Each policy below answers: **what changes**, **when to use it**, and **how it maps to the production dashboard defaults**.

::: panel-tabset
### Adaptive Gain (Inverted-U) <span class="help-icon" data-bs-toggle="tooltip" title="Target the mid-arousal zone; too low/high hurts performance (LC–NE adaptive gain)."><i class="bi bi-info-circle"></i></span>

```{r}
#| echo: false
if (requireNamespace("ggplot2", quietly = TRUE)) {
  library(ggplot2)

  # --- Parameters you'd also expose in the Training Lab ---
  band_center <- 0.55   # where you want the trainee to operate (0..1)
  band_width  <- 0.20   # width of the "optimal" zone (0..1)
  sigma_perf  <- 0.22   # curve sharpness: smaller = sharper inverted-U

  # --- Inverted-U as a Gaussian over normalized arousal (0..1) ---
  arousal <- seq(0, 1, length.out = 400)
  performance <- exp(-((arousal - band_center)^2) / (2 * sigma_perf^2))

  lo <- max(0, band_center - band_width/2)
  hi <- min(1, band_center + band_width/2)

  df <- data.frame(arousal, performance)

  ggplot(df, aes(arousal, performance)) +
    # Optimal band shading
    annotate("rect", xmin = lo, xmax = hi, ymin = -Inf, ymax = Inf,
             alpha = 0.08, fill = "#1f9bb6") +
    geom_line(linewidth = 0.9) +
    geom_vline(xintercept = c(lo, hi), linetype = 2, linewidth = 0.4) +
    annotate("text", x = lo - 0.02, y = 0.1, label = "Low arousal\n(lapse risk)",
             hjust = 1, size = 3) +
    annotate("text", x = hi + 0.02, y = 0.1, label = "High arousal\n(overload risk)",
             hjust = 0, size = 3) +
    annotate("label", x = band_center, y = 0.9, label = "Optimal band",
             fill = "white", label.size = 0.2, size = 3.1) +
    scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
    labs(title = "Adaptive Gain (Inverted-U)",
         subtitle = sprintf("Center = %.0f%%  ·  Width = %.0f%%  ·  σ = %.2f",
                            100*band_center, 100*band_width, sigma_perf),
         x = "Normalized arousal (fused index: TEPR↑, HRV↓ → higher)",
         y = "Task performance (relative)") +
    theme_minimal()
}
```

```{=html}
<p style="margin-top:0.5rem;font-size:0.95rem;">
<strong>X-axis detail:</strong> Normalized arousal 
<span class="help-icon" data-bs-toggle="tooltip" 
      title="Fusion rule: A = sigmoid(w₁·z(TEPR) – w₂·z(RMSSD)), where z() standardizes to μ=0, σ=1. Example weights: w₁=0.6, w₂=0.4. TEPR↑ and HRV↓ both push arousal higher.">
  <i class="bi bi-info-circle"></i>
</span>
= fused TEPR + HRV index ∈ [0,1].
</p>
```

-   **Maps to Dashboard.** We fuse TEPR (↑) and HRV (↓) into a **normalized arousal index** ∈ [0,1]. Alerts fire when the index leaves the **optimal band** `[lo, hi]`.

    -   Wider band → **fewer alerts**, gentler coaching.
    -   Narrower band → **tighter coaching**, higher nuisance risk.
    -   We add **hysteresis** (small margins) to prevent alert "chatter" at band edges.

-   **Notes for accuracy.**

    -   The inverted-U is **task- and person-dependent**: expertise, stakes, and fatigue shift the **peak** (band_center) and **width** (band_width). That's why you **calibrate per trainee**.
    -   "Adaptive gain" is the **mechanism** (LC-NE modulating neural gain) that can yield this non-monotonic **performance curve**.

-   **References.** Yerkes–Dodson (1908); Aston-Jones & Cohen (2005, adaptive gain).

------------------------------------------------------------------------

### Dual-Criterion (SDT) <span class="help-icon" data-bs-toggle="tooltip" title="One knob moves both decision boundaries (High-Load & Lapse) together; tunes decision bias (criteria), not d′."><i class="bi bi-info-circle"></i></span>

```{=html}
<p style="margin:.25rem 0 .35rem;font-size:0.95rem;">
<strong>X-axis:</strong> a z-scored, signed <em>evidence index</em> from biosignals (e.g., TEPR↑, RMSSD↓).
Higher → <em>High-Load</em>; lower → <em>Lapse</em>.
</p>
```

```{r}
#| echo: false
if (requireNamespace("ggplot2", quietly = TRUE)) {
  library(ggplot2)

  # --- Controls (decision-bias knobs; NOT d′) -------------------------------
  criterion_tightness <- 0.60  # 0..1: 0 = wide Normal window; 1 = tight (more alerts)
  coupling            <- 0.70  # 0..1: symmetry of Lapse vs HL movement (1 = symmetric)
  hys_margin          <- 0.15  # evidence units: enter/exit separation on each side

  base_hl    <-  1.60         # baseline HL criterion (right)
  base_lapse <- -1.60         # baseline Lapse criterion (left)
  move_range <-  1.00         # how far each side can move toward 0

  # Criteria centers (without hysteresis)
  crit_hl    <- base_hl   - criterion_tightness * move_range
  crit_lapse <- base_lapse + criterion_tightness * move_range * coupling

  # Hysteresis: enter at outer line, exit at inner line
  hi_enter <- crit_hl
  hi_exit  <- crit_hl - hys_margin
  lo_enter <- crit_lapse
  lo_exit  <- crit_lapse + hys_margin

  # --- Illustrative SDT picture (not empirical data) ------------------------
  set.seed(1)
  n       <- 2000
  x_norm  <- rnorm(n,  0, 1.0)
  x_hl    <- rnorm(n, +2, 1.0)
  x_lapse <- rnorm(n, -2, 1.0)
  df <- rbind(
    data.frame(x = x_lapse, class = "Lapse"),
    data.frame(x = x_norm,  class = "Optimal/Normal"),
    data.frame(x = x_hl,    class = "High-Load")
  )

  ggplot(df, aes(x, fill = class, color = class)) +
    # Normal decision region (between ENTER lines)
    annotate("rect", xmin = lo_enter, xmax = hi_enter, ymin = -Inf, ymax = Inf,
             alpha = 0.06, fill = "#1f9bb6") +
    # Hysteresis zones (thin bands between enter and exit)
    annotate("rect", xmin = lo_enter, xmax = lo_exit, ymin = -Inf, ymax = Inf,
             alpha = 0.06, fill = "#9ca3af") +
    annotate("rect", xmin = hi_exit,  xmax = hi_enter, ymin = -Inf, ymax = Inf,
             alpha = 0.06, fill = "#9ca3af") +
    geom_density(alpha = 0.18, linewidth = 0.6) +
    # Enter / Exit lines
    geom_vline(xintercept = c(lo_enter, hi_enter), linetype = 2, linewidth = 0.55) +
    geom_vline(xintercept = c(lo_exit,  hi_exit),  linetype = 3, linewidth = 0.55) +
    annotate("label", x = (lo_enter + hi_enter)/2, y = 0.10, label = "Decision: Normal",
             fill = "white", label.size = 0.2, size = 3.5) +
    annotate("text", x = hi_enter + 0.08, y = 0.06, hjust = 0, label = "→ HL enter",  size = 3.3) +
    annotate("text", x = hi_exit  + 0.08, y = 0.05, hjust = 0, label = "→ HL exit",   size = 3.3) +
    annotate("text", x = lo_enter - 0.08, y = 0.06, hjust = 1, label = "Lapse enter ←", size = 3.3) +
    annotate("text", x = lo_exit  - 0.08, y = 0.05, hjust = 1, label = "Lapse exit ←",  size = 3.3) +
    scale_color_manual(values = c("Lapse"="#6b7280", "Optimal/Normal"="#0ea5b7", "High-Load"="#bc3c29")) +
    scale_fill_manual(values  = c("Lapse"="#6b7280", "Optimal/Normal"="#0ea5b7", "High-Load"="#bc3c29")) +
    coord_cartesian(xlim = c(-4, 4)) +
    labs(title    = "Dual-Criterion (SDT) with Hysteresis",
         subtitle = sprintf("tightness=%.2f · coupling=%.2f · hysteresis=%.2f  |  enter:[%.2f, %.2f]  exit:[%.2f, %.2f]",
                            criterion_tightness, coupling, hys_margin,
                            lo_enter, hi_enter, lo_exit, hi_exit),
         x = "Evidence (signed index: Lapse ←   0   → High-Load)",
         y = "Density") +
    guides(color = "none", fill = "none") +
    theme_minimal() +
    theme(legend.position = "none")
}
```

**How the two figures relate:** The first figure defines the boundaries (enter/exit on each side). The second applies the **same boundaries—nudged slightly if needed so at least one crossing is visible (see subtitle)**—to a noisy signal, showing how hysteresis prevents flip-flops near a boundary.

```{r}
#| echo: false
#| fig-width: 10.5
#| fig-height: 4.2
if (requireNamespace("ggplot2", quietly = TRUE)) {
  library(ggplot2); library(grid)

  # --- signal ---------------------------------------------------------------
  set.seed(42)
  T  <- 400
  e  <- numeric(T)
  for (t in 2:T) e[t] <- 0.92*e[t-1] + rnorm(1, 0.02, 0.12)

  # --- start with EXACT thresholds from Plot 1 ------------------------------
  hi_enter2 <- hi_enter; hi_exit2 <- hi_exit
  lo_enter2 <- lo_enter; lo_exit2 <- lo_exit

  # Check if we see at least one crossing; if not, nudge minimally for demo
  need_nudge <- !(any(e > hi_enter2) || any(e < lo_enter2))
  if (need_nudge) {
    maxE <- max(e); minE <- min(e)
    if (!any(e > hi_enter2) && maxE > (hi_enter2 - 0.02)) {
      hi_enter2 <- max(hi_enter2 - 0.02, maxE - 0.03)
      hi_exit2  <- hi_enter2 - max(0.05, abs(hi_enter - hi_exit))
    }
    if (!any(e < lo_enter2) && minE < (lo_enter2 + 0.02)) {
      lo_enter2 <- min(lo_enter2 + 0.02, minE + 0.03)
      lo_exit2  <- lo_enter2 + max(0.05, abs(lo_exit - lo_enter))
    }
  }

  # --- classify: naive vs hysteresis ---------------------------------------
  state_naive <- ifelse(e > hi_enter2, "HL",
                        ifelse(e < lo_enter2, "Lapse", "Normal"))

  state_hys <- character(T); state <- "Normal"
  for (t in 1:T) {
    x <- e[t]
    if (state == "Normal") {
      if (x > hi_enter2) state <- "HL"
      else if (x < lo_enter2) state <- "Lapse"
    } else if (state == "HL") {
      if (x < hi_exit2) state <- "Normal"
    } else if (state == "Lapse") {
      if (x > lo_exit2) state <- "Normal"
    }
    state_hys[t] <- state
  }

  # long data (two rows: top = naive, bottom = hysteresis, slight visual offset)
  df_long <- rbind(
    data.frame(t = 1:T, evidence = e, state = state_naive,
               method = "Naive (top)",          y = e),
    data.frame(t = 1:T, evidence = e, state = state_hys,
               method = "Hysteresis (bottom)",  y = e - 0.06)
  )

  # thresholds legend: just Enter / Exit
  hlines <- data.frame(
    y = c(hi_enter2, hi_exit2, lo_enter2, lo_exit2),
    type = factor(c("Enter","Exit","Enter","Exit"), levels = c("Enter","Exit"))
  )

  ggplot(df_long, aes(t, y)) +
    geom_line(aes(y = evidence), linewidth = 0.45, color = "grey35", alpha = 0.7) +
    geom_hline(data = hlines, aes(yintercept = y, linetype = type),
               linewidth = 0.45, color = "black", alpha = 0.75) +
    geom_point(aes(color = state, shape = method), size = 0.9, alpha = 0.95) +
    scale_color_manual(values = c("HL"="#bc3c29","Lapse"="#6b7280","Normal"="#0ea5b7")) +
    scale_shape_manual(values = c("Naive (top)" = 16, "Hysteresis (bottom)" = 17)) +
    scale_linetype_manual(values = c("Enter"=2, "Exit"=3)) +
    labs(title = "Hysteresis reduces edge-chatter",
         subtitle = if (need_nudge) "Shapes = method; dashed = enter, dotted = exit • Note: thresholds nudged slightly for visibility"
                    else "Shapes = method; dashed = enter, dotted = exit thresholds",
         x = "Time", y = "Evidence",
         color = "State", shape = "Method", linetype = "Threshold") +
    theme_minimal() +
    theme(
      legend.position   = "bottom",
      legend.box        = "horizontal",
      legend.key.size   = grid::unit(6, "pt"),
      legend.spacing.x  = grid::unit(4, "pt"),
      legend.spacing.y  = grid::unit(2, "pt"),
      legend.box.spacing= grid::unit(2, "pt"),
      legend.title      = element_text(size = 9),
      legend.text       = element_text(size = 8),
      plot.subtitle     = element_text(size = 10)
    ) +
    guides(
      color    = guide_legend(nrow = 1, byrow = TRUE, order = 1),
      shape    = guide_legend(nrow = 1, byrow = TRUE, order = 2),
      linetype = guide_legend(nrow = 1, byrow = TRUE, order = 3)
    )
}
```

- **What this shows.** A three-state SDT layout (Lapse / Normal / High-Load) with **two decision criteria** and **hysteresis** (separate enter/exit thresholds).
  - **`criterion_tightness`** narrows or widens the Normal window by moving **both** criteria toward or away from 0.
  - **`coupling`** controls symmetry: values **< 1** move the Lapse boundary **less** than the High-Load boundary; values **> 1** move it **more**.
- **Why "Dual-Criterion," not "Sensitivity."** In SDT, **sensitivity** is **d′** (distribution separation). This policy **adjusts decision criteria (bias)**, not d′.
- **Hysteresis.** Enter/exit thresholds (and/or consecutive-sample confirmation) require **persistent evidence** to change state—reducing nuisance alerts.
- **Not a DDM.** This is SDT with persistence, not a drift–diffusion integrator; it approximates temporal integration efficiently for real-time use.
- **Maps to Dashboard.** The control sets the **HL** and **Lapse** thresholds together. Alerts still require **evidence + physiology** (e.g., HL requires **TEPR↑ or HRV↓**; Lapse prefers **low TEPR + blink anomalies**).
- **References.** Macmillan & Creelman (Signal Detection Theory); NASA-TLX background (Hart & Staveland).

------------------------------------------------------------------------

### Time-on-Task (Fatigue) <span class="help-icon" data-bs-toggle="tooltip" title="Hold steady until onset, then relax with half-life; a microbreak gives a brief reset with exponential decay."><i class="bi bi-info-circle"></i></span>

```{r}
#| echo: false
if (requireNamespace("ggplot2", quietly = TRUE)) {
  library(ggplot2); library(grid)

  # --- Parameters (match UI/control names) -----------------------------------
  c_start               <- 0.70   # starting decision threshold
  c_floor               <- 0.50   # most relaxed threshold allowed
  onset_min             <- 30     # fatigue onset time (min)
  fatigue_half_life_min <- 21     # half-life (min): time to move halfway from start to floor AFTER onset
  microbreak_min        <- 60     # minute of the microbreak (set NA for none)
  microbreak_reset      <- 0.12   # reset magnitude (toward c_start)
  microbreak_decay_min  <- 2      # decay time constant (min) of the reset

  # --- Helper: exponential relaxation + microbreak recovery ------------------
  fatigue_threshold <- function(t) {
    tau  <- fatigue_half_life_min / log(2)   # map half-life to time constant
    # baseline: hold at c_start until onset, then relax exponentially to c_floor
    base <- ifelse(t < onset_min,
                   c_start,
                   c_floor + (c_start - c_floor) * exp(-(t - onset_min) / tau))

    # apply microbreak boost ONLY after the break, then decay smoothly
    boost <- if (!is.na(microbreak_min)) {
      ifelse(t >= microbreak_min,
             microbreak_reset * exp(-(t - microbreak_min) / microbreak_decay_min),
             0)
    } else 0

    # clamp to [c_floor, c_start]
    pmin(c_start, pmax(c_floor, base + boost))
  }

  # --- Data + key reference points ------------------------------------------
  t  <- seq(0, 90, by = 0.25)
  y  <- fatigue_threshold(t)

  # Half-life time and level (exactly halfway from start to floor AFTER onset)
  t_half <- onset_min + fatigue_half_life_min
  y_half <- (c_start + c_floor) / 2

  df <- data.frame(mins = t, threshold = y)

  # --- Plot (annotated) ------------------------------------------------------
  ggplot(df, aes(mins, threshold)) +
    # shaded pre-onset region
    annotate("rect", xmin = -Inf, xmax = onset_min, ymin = -Inf, ymax = Inf,
             alpha = 0.05, fill = "grey60") +
    # reference lines
    geom_hline(yintercept = c_start, linetype = "solid",  linewidth = 0.3) +
    geom_hline(yintercept = c_floor, linetype = "dotted", linewidth = 0.3) +
    geom_vline(xintercept = onset_min,      linetype = 2, linewidth = 0.3) +
    { if (!is.na(microbreak_min)) geom_vline(xintercept = microbreak_min, linetype = 2, linewidth = 0.3) } +
    # main curve
    geom_line(linewidth = 0.8) +
    # half-life marker
    geom_point(aes(x = t_half, y = y_half), size = 2) +
    geom_segment(aes(x = t_half, xend = t_half, y = c_start, yend = y_half),
                 arrow = arrow(length = grid::unit(0.15, "cm")), linewidth = 0.3) +
    # labels
    annotate("text", x = onset_min - 2, y = c_start + 0.006, hjust = 1,
             label = "Onset", size = 4) +
    { if (!is.na(microbreak_min))
        annotate("text", x = microbreak_min + 2, y = c_start - 0.01, hjust = 0,
                 label = "Microbreak", size = 4) } +
    annotate("text", x = t_half + 2, y = y_half + 0.005, hjust = 0,
             label = "Half-life → halfway to floor", size = 4) +
    annotate("text", x = max(t) - 5, y = c_floor + 0.004, hjust = 1,
             label = "Floor", size = 4) +
    annotate("text", x = 5, y = c_start + 0.004, hjust = 0,
             label = "Start", size = 4) +
    labs(
      title = "Time-on-Task (Fatigue): flat → relax → reset",
      subtitle = sprintf("Onset=%d min · Half-life=%d min · Microbreak=%s",
                         onset_min, fatigue_half_life_min,
                         ifelse(is.na(microbreak_min), "none", paste0(microbreak_min, " min"))),
      x = "Time on task (min)",
      y = "High-Load decision threshold"
    ) +
    theme_minimal() +
    theme(legend.position = "none")
}
```

```{r}
#| echo: false
#| results: asis
# Auto-updating description for the fatigue-adaptive curve
halfway_time <- onset_min + fatigue_half_life_min
fmt <- function(x, d=2) formatC(x, format="f", digits=d)

cat(
  "::: {.callout-note}\n",
  "**How to read this curve**\n\n",
  "- **Pre-onset (t < ", onset_min, " min):** the **decision threshold** stays at **", fmt(c_start), "** (no fatigue modeled yet).\n",
  "- **Post-onset:** the threshold relaxes **exponentially** toward the **floor** **", fmt(c_floor),
    "** — i.e., the system becomes more tolerant of High-Load detections as vigilance degrades.\n",
  if (!is.na(microbreak_min))
    paste0("- **Microbreak (t = ", microbreak_min, " min):** brief **reset boost** that decays over ~",
           microbreak_decay_min, " min.\n")
  else "",
  "- **Half-life marker:** at **t = onset + half-life = ", onset_min, " + ", fatigue_half_life_min,
    " = ", halfway_time, " min**, the threshold is **halfway** between **", fmt(c_start),
    "** and **", fmt(c_floor), "**.\n",
  "- Visual cues: **solid line** = start (", fmt(c_start),
    "); **dotted line** = floor (", fmt(c_floor),
    "); **vertical dashed lines** = onset",
    if (!is.na(microbreak_min)) " and microbreak" else "", ".\n",
  ":::",
  sep = ""
)
```

- This policy adjusts the **criterion** (decision threshold) over time; it does **not** assume the evidence itself drifts.
- The **half-life** parameter is interpretable: after *onset + half-life*, the threshold sits exactly halfway between **start** and **floor**.
- Microbreak behavior models the short-lived recovery documented in vigilance/OR ergonomics; tune `microbreak_reset` (size) and `microbreak_decay_min` (return speed) per task/surgeon.
- Calibrate per individual; not all tasks show strictly monotonic fatigue.

-   **Maps to Dashboard.** Drives the **time-on-task** feature and the **microbreak button**; after breaks, we expect **HRV/tremor** to normalize within \~120 s (we log this for efficacy).

-   **References.** Warm, Parasuraman & Matthews (2008, vigilance & workload).
:::

------------------------------------------------------------------------

## Why thresholds must adapt

:::: {.callout-tip collapse="false"}
## 🔬 Interactive Training Lab Demo

Click below to launch the interactive training lab in a new window. The lab lets you compare three adaptive threshold policies (Adaptive Gain, Dual-Criterion, and Time-on-Task) on the same data stream.

::: {style="text-align:center;margin:20px 0;"}
<a href="https://0z6q8c-mohammad0dastgheib.shinyapps.io/surgical-training-lab/" target="_blank" rel="noopener noreferrer" style="display:inline-block;padding:12px 24px;background:var(--accent);color:white;text-decoration:none;border-radius:8px;font-weight:600;box-shadow:0 2px 4px rgba(0,0,0,0.1);"> Launch Training Lab → </a>
:::

*Opens in a new tab. The app may take a few seconds to load.*
::::

> Switch between policies on the same stream. Notice how the same physiologic trace produces different coaching behavior. That is the point: **policy is a choice**, and it should be teachable.

------------------------------------------------------------------------

## Production Dashboard

<!-- Prefer MP4 for small, crisp playback. If you only have a GIF, replace the <video> with an image. -->

<video src="case_study/images/dashboard-demo.mp4" autoplay loop muted playsinline style="width:100%;border-radius:12px">

</video>

The dashboard is not "another plot." It's **decision support** that lives inside real constraints:

-   **Zero headgear:** pupil + HRV + grip/tremor; nothing on the face or scalp.
-   **\< 60 s setup:** no gels, no caps, no calibration theatrics.
-   **Alarm hygiene:** ≤ 0.6 alerts/min, snoozable, and state-aware (non-critical cues defer during suturing).

The UI borrows a clinical design language—calm background, a single accent, and status colors reserved for meaning only (green/amber/red). The rest is quiet on purpose.

------------------------------------------------------------------------

## Methods

**Signals.** Pupil diameter (tonic + TEPR), grip force (mean + CV%), hand-tremor RMS in 8–12 Hz, and HRV (SDNN/RMSSD). These four survive the OR: they're non-intrusive, robust, and interpretable.

**Features.** Strictly causal windows. Hippus power (0.05–0.3 Hz), TEPR amplitude, grip CV% and spike rate, tremor RMS & growth vs personal baseline, and HRV short-term variability. Time-on-task is explicit.

**Model.** A calibrated gradient-boosting model produces **probabilities** for Optimal / High Load / Lapse. Post-hoc **fusion rules** enforce clinical common sense (e.g., HRV drop + TEPR spike to confirm High Load; blink anomaly + low TEPR to confirm Lapse). Thresholds are **policy-tunable** and **per-surgeon calibrated**.

**Validation.** Leave-one-surgeon-out on simulated streams to prove the architecture, **not** to publish final accuracy. The next step is training-center telemetry.

------------------------------------------------------------------------

## Results that matter (ops KPIs)

```{r}
#| label: metrics-gt
if (requireNamespace("gt", quietly=TRUE) &&
requireNamespace("readr", quietly=TRUE) &&
requireNamespace("dplyr", quietly=TRUE)) {

library(readr); library(dplyr); library(gt)

path <- "data/processed/demo_metrics.csv"
  metrics <- if (file.exists(path)) read_csv(path, show_col_types = FALSE) else
    tibble::tibble(Alert_Burden_per_min = 0.42,
HighLoad_Minutes_per_hour = 12.8,
                   TimeToRecovery_sec = 95)

gt(metrics) |>
fmt_number(where(is.numeric), decimals = 2) |>
cols_label(
Alert_Burden_per_min = "Alert Burden (per min)",
HighLoad_Minutes_per_hour = "High-Load (min/hr)",
TimeToRecovery_sec = "Time-to-Recovery (sec)"
) |>
data_color(
columns = c(Alert_Burden_per_min, HighLoad_Minutes_per_hour, TimeToRecovery_sec),
colors = scales::col_bin(
        palette = c("#27ae60","#f39c12","#e74c3c"),
        bins = c(-Inf, 0.6, 1.0, Inf)
)
) |>
tab_options(table.border.top.color = "#e5e7eb",
table.border.bottom.color = "#e5e7eb")

} else { cat("Install packages gt, readr, dplyr to render this table.") }
```

------------------------------------------------------------------------

## Live clinical-style table with literature ranges

```{r}
#| label: features-gt
if (requireNamespace("gt", quietly=TRUE) &&
requireNamespace("readr", quietly=TRUE) &&
requireNamespace("dplyr", quietly=TRUE)) {

library(readr); library(dplyr); library(gt)

# ---- reference ranges (fallback included) ----
ref_path <- "data/reference_ranges.csv"
  refs <- if (file.exists(ref_path)) read_csv(ref_path, show_col_types = FALSE) else
tibble::tibble(
Feature = c("Pupil Diameter","Grip Force","Tremor RMS (8–12Hz)","HRV (RMSSD)",
"Grip CV%","Time-on-Task","Normal Prob","High Load Prob","Lapse Prob"),
Unit = c("mm","N","μm","ms","%","min","%","%","%"),
baseline_mean = c(3.5,3.0,100,40,8,10,60,30,10),
baseline_sd   = c(0.2,1.0,30,10,2,NA,NA,NA,NA),
normal_low    = c(3.1,1.5,60,30,5,0,40,0,0),
normal_high   = c(3.9,5.0,120,60,12,30,100,60,30),
alert_low     = c(NA,NA,NA,25,NA,NA,0,0,0),
alert_high    = c(4.8,7.0,180,NA,15,60,100,100,100),
direction     = c("high_worse","high_worse","high_worse","low_worse","high_worse","high_worse",
"low_worse","high_worse","high_worse")
)

# ---- current snapshot (fallback included) ----
snap_path <- "data/processed/demo_features_snapshot.csv"
  snap <- if (file.exists(snap_path)) read_csv(snap_path, show_col_types = FALSE) else
tibble::tibble(
Feature = c("Pupil Diameter","Grip Force","Tremor RMS (8–12Hz)","HRV (RMSSD)",
"Grip CV%","Time-on-Task","Normal Prob","High Load Prob","Lapse Prob"),
Value   = c(3.62,5.30,78,45,9.3,10.0,43.5,40.5,16.0),
Unit    = c("mm","N","μm","ms","%","min","%","%","%")
)

  # ---- helpers ----
status_row <- function(val, r) {
dir <- r$direction; nl<-r$normal_low; nh<-r$normal_high; al<-r$alert_low; ah<-r$alert_high
if (is.na(val)) return("Unknown")
if (dir=="high_worse") {
if (!is.na(ah) && val>ah) "Critical" else if (!is.na(nh) && val>nh) "Elevated" else "Normal"
} else if (dir=="low_worse") {
if (!is.na(al) && val<al) "Critical" else if (!is.na(nl) && val<nl) "Elevated" else "Normal"
} else {
if ((!is.na(al) && val<al) || (!is.na(ah) && val>ah)) "Critical"
else if ((!is.na(nl) && val<nl) || (!is.na(nh) && val>nh)) "Elevated"
else "Normal"
}
}
d_cohen <- function(val, m, s) ifelse(is.na(s) || s<=0, NA_real_, (val - m)/s)

df <- snap |>
left_join(refs, by = c("Feature","Unit")) |>
rowwise() |>
mutate(
Status = status_row(Value, cur_data()),
Effect = d_cohen(Value, baseline_mean, baseline_sd),
Ref_CI = if (!is.na(baseline_mean) && !is.na(baseline_sd))
sprintf("%.2f–%.2f", baseline_mean-1.96*baseline_sd, baseline_mean+1.96*baseline_sd)
else ""
) |>
ungroup() |>
mutate(
Status_Icon = dplyr::case_when(
        Status=="Normal"   ~ "<span style='color:#27ae60'>●</span> Normal",
Status=="Elevated" ~ "<span style='color:#f39c12'>▲</span> Elevated",
Status=="Critical" ~ "<span style='color:#e74c3c'>⚠</span> Critical",
TRUE ~ "·"
),
Value_fmt = dplyr::case_when(
        Unit=="mm"  ~ sprintf("%.2f mm", Value),
        Unit=="μm"  ~ sprintf("%.0f μm", Value),
        Unit=="N"   ~ sprintf("%.2f N", Value),
        Unit=="ms"  ~ sprintf("%.0f ms", Value),
        Unit=="%"   ~ sprintf("%.1f%%", Value),
        Unit=="min" ~ sprintf("%.1f min", Value),
        TRUE        ~ as.character(signif(Value, 3))
),
Effect_fmt = ifelse(is.na(Effect),"",sprintf("%.2f", Effect))
)

  gt(df |> dplyr::select(Feature, Value_fmt, Ref_CI, Effect_fmt, Status_Icon)) |>
cols_label(
Feature    = "Feature",
Value_fmt  = html("Value<br><span style='font-size:.8em'>(Live)</span>"),
Ref_CI     = html("Literature<br><span style='font-size:.8em'>(≈95% CI)</span>"),
Effect_fmt = html("Effect Size<br><span style='font-size:.8em'>(Cohen's d)</span>"),
Status_Icon= "Status"
) |>
fmt_markdown(columns = c(Ref_CI, Status_Icon)) |>
tab_style(
      style = list(cell_fill(color = "#e8f5e9"), cell_text(color = "#0b1526")),
locations = cells_body(columns = "Value_fmt", rows = df$Status=="Normal")
) |>
    tab_style(
      style = cell_text(color = "#0b1526"),
      locations = cells_body(columns = "Value_fmt", rows = df$Status=="Elevated")
    ) |>
    tab_style(
      style = cell_text(color = "#0b1526"),
      locations = cells_body(columns = "Value_fmt", rows = df$Status=="Critical")
    ) |>
tab_style(
style = cell_text(weight = "bold"),
locations = cells_body(columns = "Effect_fmt",
rows = !is.na(df$Effect_fmt) & as.numeric(df$Effect_fmt) > 0.8)
) |>
tab_footnote(
footnote = html("Colors: <span style='color:#27ae60'>Normal</span> | <span style='color:#f39c12'>Elevated</span> | <span style='color:#e74c3c'>Critical</span>"),
locations = cells_column_labels(columns = "Value_fmt")
)

} else { cat("Install packages gt, readr, dplyr to render this table.") }
```

------------------------------------------------------------------------

## Product vs. Lab — how they fit

```{r}
library(gt)
library(dplyr)

# Create the data
comparison_data <- tibble(
  Aspect = c("Purpose", "Audience", "Features", "Status"),
  `Production Dashboard` = c(
    "Real-time monitoring & decision support",
    "Clinicians, safety officers",
    "GT live table, deployable app, tuned alerts",
    "Stable, zero-headgear UI"
  ),
  `Training Lab` = c(
    "Theory exploration & threshold policy",
    "Educators, researchers",
    "Three paradigms, side-by-side comparisons",
    "Experimental, fast iteration"
  )
)

# Create the gt table
comparison_data %>%
  gt() %>%
  tab_style(
    style = cell_fill(color = "#f8f9fa"),
    locations = cells_body(columns = Aspect)
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(columns = Aspect)
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "#e8f5e9"),
      cell_text(align = "left")
    ),
    locations = cells_body(columns = `Production Dashboard`)
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "#fff8e1"),
      cell_text(align = "left")
    ),
    locations = cells_body(columns = `Training Lab`)
  ) %>%
  tab_options(
    table.width = pct(100),
    table.font.size = px(14)
  )

```

------------------------------------------------------------------------

## From SST to the OR — what transferred

-   **Alarm hygiene over cleverness.** A good model with bad alerting is a bad product.
-   **Interpretability isn't optional.** Surgeons won't read a confusion matrix mid-case; they will understand "High Load confirmed by HRV drop + TEPR spike."
-   **Friction is the enemy.** Every cable, cap, or password prompt kills adoption. This is why I stayed with **zero headgear** and **\< 60-second setup**.

------------------------------------------------------------------------

## Deployment & Privacy

This ships as a Docker image or ShinyApps deployment and can be embedded in training portals with a single `<iframe>`. On the privacy front, **surgeon biometrics are ephemeral by default**; logs are de-identified for QA and research with explicit consent. Nothing about this removes the surgeon from the loop; it simply helps them and their instructors see what matters, when it matters.

------------------------------------------------------------------------

## What's next

-   **Training pilots** in a robotic lab to quantify **High-Load min/hr** and **time-to-recovery** improvements for residents.
-   **State-adaptive assistance:** small camera framing & motion-scaling tweaks during high load; defer non-urgent prompts.
-   **Intervention efficacy logging:** for every alert or microbreak, track whether HRV/tremor normalize within \~120 s to auto-tune thresholds per surgeon.
